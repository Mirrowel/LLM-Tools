<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Benchmark Logs - MirroBench</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #e5e5e5;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body class="p-0 m-0 overflow-hidden">
    <div id="app" class="h-screen flex flex-col">
        <!-- Header -->
        <div class="bg-gray-800 border-b border-gray-700 px-4 py-3 flex items-center justify-between flex-shrink-0">
            <div class="flex items-center space-x-3">
                <i data-lucide="terminal" class="w-5 h-5 text-red-500"></i>
                <h1 class="text-lg font-bold">Benchmark Logs</h1>
            </div>
            <div class="flex items-center space-x-3">
                <button @click="toggleAutoScroll"
                        :class="['px-3 py-1 text-xs rounded transition flex items-center space-x-1',
                                 autoScroll ? 'bg-green-600 hover:bg-green-500 text-white' : 'bg-gray-600 hover:bg-gray-500 text-white']">
                    <i :data-lucide="autoScroll ? 'check-circle' : 'circle'" class="w-3 h-3"></i>
                    <span>Auto-scroll</span>
                </button>
                <span class="px-3 py-1 text-xs font-semibold rounded"
                      :class="{
                          'bg-gray-600': status === 'idle',
                          'bg-green-600': status === 'running',
                          'bg-blue-600': status === 'completed',
                          'bg-red-600': status === 'failed',
                          'bg-yellow-600': status === 'cancelled'
                      }">
                    {{ status.toUpperCase() }}
                </span>
            </div>
        </div>

        <!-- Progress Info -->
        <div v-if="progress && status === 'running'" class="bg-gray-800 border-b border-gray-700 px-4 py-2 grid grid-cols-4 gap-2 flex-shrink-0 text-xs">
            <div>
                <span class="text-gray-400">Model:</span>
                <span class="font-semibold ml-1">{{ progress.current_model || 'N/A' }} ({{ progress.current_model_index + 1 }}/{{ progress.total_models }})</span>
            </div>
            <div>
                <span class="text-gray-400">Phase:</span>
                <span class="font-semibold ml-1 capitalize">{{ progress.current_phase.replace(/_/g, ' ') }}</span>
            </div>
            <div>
                <span class="text-gray-400">Questions:</span>
                <span class="font-semibold ml-1">{{ progress.questions_completed }}/{{ progress.questions_total }}</span>
            </div>
            <div>
                <span class="text-gray-400">Elapsed:</span>
                <span class="font-semibold ml-1">{{ formatDuration(progress.elapsed_seconds) }}</span>
            </div>
        </div>

        <!-- Logs Container -->
        <div ref="logContainer" class="flex-1 overflow-y-auto bg-black p-4">
            <div class="space-y-1">
                <div v-for="(log, index) in logs" :key="index" class="text-gray-300 text-sm">
                    {{ log }}
                </div>
                <div v-if="logs.length === 0" class="text-gray-500 text-center py-8">
                    Waiting for logs...
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    status: 'idle',
                    job: null,
                    progress: {
                        current_model: null,
                        current_model_index: 0,
                        total_models: 0,
                        current_phase: 'initializing',
                        questions_completed: 0,
                        questions_total: 0,
                        elapsed_seconds: 0
                    },
                    logs: [],
                    autoScroll: true,
                    polling: null
                };
            },
            mounted() {
                // Listen for updates from parent window
                window.addEventListener('message', this.handleMessage);

                // Start polling as backup
                this.startPolling();

                // Initialize Lucide icons
                lucide.createIcons();
            },
            beforeUnmount() {
                window.removeEventListener('message', this.handleMessage);
                this.stopPolling();
            },
            methods: {
                handleMessage(event) {
                    // Verify origin for security
                    if (event.origin !== window.location.origin) {
                        return;
                    }

                    const data = event.data;
                    if (data.type === 'benchmark-update') {
                        this.status = data.status;
                        this.job = data.job;
                        this.progress = data.progress || this.progress;
                        this.logs = data.logs || [];

                        // Auto-scroll if enabled
                        if (this.autoScroll) {
                            this.$nextTick(() => {
                                const container = this.$refs.logContainer;
                                if (container) {
                                    container.scrollTop = container.scrollHeight;
                                }
                            });
                        }

                        // Re-render icons
                        this.$nextTick(() => {
                            lucide.createIcons();
                        });
                    }
                },

                toggleAutoScroll() {
                    this.autoScroll = !this.autoScroll;
                    if (this.autoScroll) {
                        this.$nextTick(() => {
                            const container = this.$refs.logContainer;
                            if (container) {
                                container.scrollTop = container.scrollHeight;
                            }
                        });
                    }

                    // Re-render icons
                    this.$nextTick(() => {
                        lucide.createIcons();
                    });
                },

                async startPolling() {
                    // Poll independently in case parent window is closed/navigated
                    this.polling = setInterval(async () => {
                        try {
                            const response = await fetch('/api/benchmark/status');
                            const data = await response.json();

                            this.status = data.status;
                            if (data.job) {
                                this.job = data.job;
                                this.progress = data.job.progress;
                                this.logs = data.job.logs || [];

                                // Auto-scroll if enabled
                                if (this.autoScroll) {
                                    this.$nextTick(() => {
                                        const container = this.$refs.logContainer;
                                        if (container) {
                                            container.scrollTop = container.scrollHeight;
                                        }
                                    });
                                }
                            }

                            // If completed/failed/cancelled, stop polling
                            if (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled') {
                                this.stopPolling();
                            }
                        } catch (error) {
                            console.error('Error polling status:', error);
                        }
                    }, 500);
                },

                stopPolling() {
                    if (this.polling) {
                        clearInterval(this.polling);
                        this.polling = null;
                    }
                },

                formatDuration(seconds) {
                    if (!seconds) return '0s';

                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const secs = Math.floor(seconds % 60);

                    if (hours > 0) {
                        return `${hours}h ${minutes}m ${secs}s`;
                    } else if (minutes > 0) {
                        return `${minutes}m ${secs}s`;
                    } else {
                        return `${secs}s`;
                    }
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
